-- pairup operator.
-- pairup (ps ++ pi ++ qs ++ qi) evaluates to <<po, qo>, rs>, provided that
-- 1) ps and qs represent the lambda calculus programs p and q, respectively,
-- 2) p (pi ++ X) evaluates to <po, X> for all X (even non-lists), and
-- 3) q qi (ps ++ pi) evaluates to <qo, rs>.
let
  true = \x \y x;
  false = \x \y y;
  nil = false;
  cons = \a \b \p p a b;

  -- Enabling IFDIRTY replaces some omegas by suitable variables to save space.
  -- IFDIRTY,  !CPS: 788 bits / CPS: 802
  -- !IFDIRTY, !CPS: 878 bits / CPS: 847
  IFDIRTY = true;
  IFCPS = false;

  -- Parse and compile binary lambda calculus.
  uni = \abs \app let uni = \cnt \rs \xs
    xs (\b0 \ys ys (\b1
      let rs0 = \ts rs (\p p b0 (\p p b1 ts)) in
        b0 (uni (\v1 (b1 (cnt (abs v1))
                         (uni (\v2 cnt (\ctx app (v1 ctx) (v2 ctx)))))) rs0)
           (b1 (cnt (\ctx ctx b1) rs0)
               (\d uni (\v cnt (\ctx v (ctx b1))) (\ts rs (\p p b0 ts)) ys))))
  in \cnt uni cnt (\f f);

  -- For reference, a generic monadic evaluator, using types
  --   Term = [m Val] -> m Val, Val ~ m Val -> m Val.
  -- appM = \ca \cb \ctx bind (ca ctx) (\a a (cb ctx));
  -- absM = \ca \ctx return (\cb ca (\p p cb ctx));

  ------------------------------------------------------------------------
  -- Pair evaluator, using types
  --   Term = [(label, Val)] -> (label, Val), Val ~ (label, Val) -> (label, Val)
  -- The label is usually 'omega', but the input is labelled such that each
  -- tail of io is initially labelled with the corresponding prefix ys.

  omega = omega;
  absP =  \ca \ctx \p p(IFDIRTY (\f f) omega) (\cb ca (\p p cb ctx));
  appP = \ca \cb ca (\d \a a cb);

  boolP = \x \p p (IFDIRTY p omega) (\e \p p (IFDIRTY p omega) (\f x e f));
  listP = \ys (\x \xs
     \p p (ys nil)
     (\e e false (boolP x) false (xs (listP (\rs ys (\p p x rs))))));

  pairupP = uni absP appP (\prog \ps \pi
     let pspi = \d ps (
           prog (IFDIRTY d omega)
           false
           (pi (listP (\f f)))
           false
           (\p p (IFDIRTY p omega) (\e \p p (IFDIRTY p omega) (\e e)))
           true);
         -- Direct evaluator, using the identity monad.
         abs = \ca \ctx (\cb ca (\p p cb ctx));
         app = \ca ca;
         eval = uni abs app (IFDIRTY (\f f) (\p \ps p omega))
     in eval (ps pi) (\po \qs eval qs (pspi qs) (\qo \rs \p p (\p p po qo) rs)));

  ------------------------------------------------------------------------
  -- CPS evaluator. C a = (a -> label -> label) -> label -> label
  --   returnC = \a \r r a;
  --   bindC = \ma \mb \r ma (\a mb a r);
  -- The label -> label function keeps track of the most recently seen tail
  -- of the input.

  absC = \ca \ctx \r \d r (\cb ca (\p p cb ctx)) (IFDIRTY (\t t) omega);
  appC = \ca \cb \r ca (\a a cb r);

  listC = \ys \x \xs
    let mx = \r r (\a \r r (\b x a b));
        mxs = xs (listC (\rs ys (\p p x rs))) in
    \r \d r (\cb (\r cb (\a a mx (\a a mxs r)))) (ys nil);

  pairupC = uni absC appC (\prog \ps \pi
     let pspi = ps (
           prog
             (IFDIRTY pi omega)
             (\a a (pi (listC (\f f)))
               (\a a (\r r (\d \r r (\b b))) (\a \f f)))
             (IFDIRTY pi omega));

         -- Direct evaluator, using the identity monad.
         abs = \ca \ctx (\cb ca (\p p cb ctx));
         app = \ca ca;
         eval = uni abs app (IFDIRTY (\p p) (\p \ps p omega))
     in eval (ps pi) (\po \qs eval qs pspi (\qo \rs \p p (\p p po qo) rs)));

  main = IFCPS pairupC pairupP
in main

-- ./blc u @pairup2.lam @delimit.blc++1111000111001++@pairlen.blc
-- <<11010,11010110>,>
-- ./blc u @pairup2.lam @delimit2.blc++1110101110000000000++@pairlen.blc++1010
-- <<10000000000,00000000>,1010>
