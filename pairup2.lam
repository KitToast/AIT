-- pairup operator.
-- pairup (ps ++ pi ++ qs ++ qi) evaluates to <<po, qo>, rs>, provided that
-- 1) ps and qs represent the lambda calculus programs p and q, respectively,
-- 2) p (pi ++ X) evaluates to <po, X> for all X (even non-lists), and
-- 3) q qi (ps ++ pi) evaluates to <qo, rs>.
let
  true = \x \y x;
  false = \x \y y;
  nil = false;
  cons = \a \b \p p a b;

  -- Enabling IFDIRTY replaces some omegas by suitable variables to save space.
  -- IFDIRTY,  !CPS: 711 bits / CPS: 722
  -- !IFDIRTY, !CPS: 796 bits / CPS: 790
  IFDIRTY = true;
  IFCPS = false;

  ----------------------------------------------------------------------------
  -- Parse and compile binary lambda calculus.
  --
  -- For reference, a generic monadic evaluator, using type
  --   Val ~ m Val -> m Val
  -- would be  uni return (liftM2 id) (\prog \ps \rs prog omega (encode rs))
  -- where encode :: [Bool] -> m Val.
  --
  -- In the continuation, ps contains the consumed bits as a difference list.

  uni = \abs \app let uni = \cnt \ps \xs
    xs (\b0 let ps0 = \ts ps (\p p b0 ts) in
      \ys \uni \cnt ys (\b1
        let ps1 = \ts ps0 (\p p b1 ts) in
          b0 (uni (\v1 (b1 (cnt (\ctx abs (\v2 v1 (\p p v2 ctx))))
                           (uni (\v2 cnt (\ctx app (v1 ctx) (v2 ctx)))))))
             (b1 (cnt (\ctx ctx b1))
                 (\d \d uni (\v cnt (\ctx v (ctx b1))) ps0 ys)) ps1)) uni cnt
  in \cnt uni cnt (\f f);

  ----------------------------------------------------------------------------
  -- Pair evaluator, using m a = (label, a).
  -- The label is usually 'omega', but the input is labelled such that each
  -- tail of io is initially annotated with the corresponding prefix ys.

  omega = omega;
  absP = \v \p p (IFDIRTY p omega) v;
  appP = \ca ca false;

  listP = \x \xs \ys
     let mx = absP (\e absP (x e));
         mxs = xs listP (\rs ys (\p p x rs)) in
     \p p (ys nil) (\e e false mx false mxs);

  pairupP = uni absP appP (\prog \ps \pi
    let pspi = \d ps (
          prog (IFDIRTY d omega)
          false
          (pi listP (\f f))
          false
          (\p p (IFDIRTY p omega) (\e \p p (IFDIRTY p omega) (\e e)))
          true);
        -- Direct evaluator, using the identity monad.
        eval = uni (\f f) (\f f) (IFDIRTY (\f f) (\p \ps p omega))
    in eval (ps pi) (\po \qs eval qs (pspi qs) (\qo \rs \p p (\p p po qo) rs)));

  ----------------------------------------------------------------------------
  -- CPS evaluator, using m a = (a -> label -> label) -> label -> label
  --   returnC = \a \r r a;
  --   bindC = \ma \mb \r ma (\a mb a r);
  -- The label -> label function keeps track of the most recently seen tail
  -- of the input.

  absC = \v \r IFDIRTY (r v) (\d r v omega);
  appC = \ca \cb \r ca (\a a cb r);

  listC = \x \xs \ys
    let mx = \r r (\a \r r (x a));
        mxs = xs listC (\rs ys (\p p x rs)) in
    \r \d r (\cb (\r cb (\a a mx (\a a mxs r)))) (ys nil);

  pairupC = uni absC appC (\prog \ps \pi
    let pspi = \d ps (
          prog (IFDIRTY d omega)
          (\a a (pi listC (\f f))
            (\a a (\r r (\d \r r (\b b))) (\a \f f)))
          (IFDIRTY d omega));

        -- Direct evaluator, using the identity monad.
        eval = uni (\f f) (\f f) (IFDIRTY (\p p) (\p \ps p omega))
    in eval (ps pi) (\po \qs eval qs (pspi qs) (\qo \rs \p p (\p p po qo) rs)));

  main = IFCPS pairupC pairupP
in main

-- ./blc u @pairup2.lam @delimit.blc++1111000111001++@pairlen.blc
-- <<11010,11010110>,>
-- ./blc u @pairup2.lam @delimit2.blc++1110101110000000000++@pairlen.blc++1010
-- <<10000000000,00000000>,1010>
